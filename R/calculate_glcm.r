#' Estimates the gcc value for a region of interest
#' automatically generated by any given algorithm
#'
#' @param img: RGB image to process (filename or 3-layer RGB stack or brick)
#' @param plot: plot resulting image with all available information
#' @keywords gcc calculation
#' @export
#' @examples
#' # no examples yet

calculate_glcm = function(img,
                         roi = NULL,
                         plot = FALSE){

  # set default file type
  file_type = "img"

  # verify data formats if not transform
  # to the correct data format
  if (class(img) == "character"){

    # set file type
    file_type = "file"

    # read in the image to estimate the region of interest of
    img = raster::brick(img)
  }

  # additional check if the stack / brick has three layers
  if (raster::nlayers(img) != 3){
    stop("the raster object does not have the required 3 (RGB) layers!")
  }

  # if no roi is specified calcualte the roi
  if (is.null(roi)){
    # estimate an ROI
    roi_data = estimate_roi(img, plot = plot)
    
    # split out the roi and horizon data
    roi = roi_data$roi
  }

  # calculate various glcm indices
  # on the green channel
  green_channel = raster::subset(img_region,2)
  
  # fix windows relative size based upon the size of the 
  # image to process, this to standardize the metrics across
  # various image inputs
  glcm_data = glcm(green_channel,
                   window = c(5,5),
                   statistics = c("variance", "homogeneity", "contrast",
                                  "dissimilarity", "entropy", "second_moment",
                                  "correlation"))
  
  # select the ROI from the original image
  img_region = intersect(glcm_data,roi)
  
  # calculate stats across region of interest
  img_region_stats = cellStats(img_region, mean, na.rm = TRUE)
  
  # return values as a structure list
  return(list("roi" = roi,
              "horizon" = roi_data$horizon,
              "glcm" = img_region_stats))
}
